# Product Capabilities: What Products CAN Do vs. What We Say They Do

**Goal:** JARVIS should be aware of what products **actually can do** (from code and runtime) — not only what we **say** they do (products.json description, README, marketing).

---

## The gap

| Source | What it is | Limitation |
|--------|------------|------------|
| **products.json `description`** | One-line "what it is" — what we **say** the product is | Static; can drift from code. |
| **README / docs** | Marketing, setup, feature lists | Often aspirational or outdated. |
| **Code + index** | What the repo actually implements (APIs, features, flows) | **Ground truth** — requires JARVIS to query it. |
| **Optional: capabilities doc / Echeo scan** | Durable list of capabilities derived from code | Best of both if we generate and maintain it. |

JARVIS should answer **"what can [product] do?"** and **"what does [product] support?"** using **code-grounded** sources first, then layer in the declared description. Don't rely only on products.json.

---

## How JARVIS learns what products CAN do

1. **products.json** — Read for product `name`, `repo`, and `description` (what we say). Use as **context**, not as the only source for capabilities.
2. **repo-knowledge (code-grounded)** — For that product's **repo** (e.g. olive, echeo, BEAST-MODE):
   - **repo_summary(repo)** — High-level summary of what the repo does (from indexed chunks). Use when the user asks "what can [product] do?" or "summarize [product]."
   - **repo_search(repo, query)** — Semantic search **within that repo** (e.g. "OAuth flow," "cart API," "list parsing," "capabilities") to find what the code actually implements.
   - **repo_file(repo, path)** — When you know a path (e.g. README, CAPABILITIES.md, API spec), pull specific content.
3. **Optional: capabilities artifact** — If a product repo has a **CAPABILITIES.md**, **FEATURES.md**, or an Echeo-generated capabilities list, JARVIS can read it via repo_file or repo_search. Prefer that over description-only when answering "what can X do?"

**Index requirement:** The product's repo must be **indexed** (in repos.json and `node scripts/index-repos.js` run for it) for repo_summary/repo_search to work. If not indexed, JARVIS can only use products.json description and any linked docs.

---

## Instructions for JARVIS

When the user asks **"what can [product] do?"**, **"what does [product] support?"**, **"what are [product]'s capabilities?"**, or when you are **doing deep work on a product**:

1. **Resolve the product** — Read products.json; get the product's `repo` (e.g. olive, echeo).
2. **Get code-grounded capabilities** — Use **repo_summary** for that repo and/or **repo_search** in that repo with queries like "capabilities," "features," "API," "what it does," or the user's specific question. If the repo has CAPABILITIES.md or similar, use **repo_file** or repo_search to read it.
3. **Combine with declared** — Use products.json `description` as one-line context; **prefer or emphasize** what repo_summary and repo_search return as "what it can do" (actual), and note "we also describe it as: [description]" (declared) if useful.
4. **If repo is not indexed** — Say so and answer from products.json + any docs you have; suggest indexing that repo so JARVIS can answer from code next time.

When **planning or doing deep work** on a product, **bootstrap with repo_summary(repo)** (and optionally repo_search for "architecture," "main flows") so JARVIS is aware of what the product actually does before proposing changes.

---

## Optional: durable capabilities per product

To make "what can X do?" even more reliable:

- **Per-repo CAPABILITIES.md** — Maintain (or generate) a file in each product repo that lists capabilities, APIs, and features. JARVIS reads it via repo_file or repo_search. Can be generated by Echeo (`echeo --path ...`) or a script.
- **products.json `capabilitiesSource`** — Optional field pointing to a path or URL (e.g. `"capabilitiesSource": "CAPABILITIES.md"` or a URL to a generated report). JARVIS then knows to read that when answering capability questions.
- **Echeo scan** — Echeo scans codebases for capabilities. Run periodically per product and store the result (file in repo or in a table); JARVIS uses it as the "what it can do" source.

These are **optional**; repo_summary + repo_search already give JARVIS code-grounded awareness as long as the repo is indexed.

---

## Summary

| Question | JARVIS should |
|----------|----------------|
| "What can [product] do?" | Use repo_summary(product.repo) and repo_search in that repo; combine with products.json description; prefer code-grounded answer. |
| "What does [product] support?" | Same — repo_search(repo, "support" or "features") + repo_summary. |
| Deep work on [product] | Bootstrap with repo_summary(repo) (and repo_search for architecture/flows) so context is what the code does, not only what we say. |
| Repo not indexed? | Answer from products.json + docs; suggest indexing the repo. |

**TL;DR:** products.json = what we **say**; repo-knowledge (repo_summary, repo_search) = what the code **can do**. JARVIS should use both and prefer code-grounded when answering capability questions.
